{"ast":null,"code":"var _jsxFileName = \"/home/anjali/Desktop/Snake Game/src/Board/Board.jsx\";\nimport React, { useEffect, useState } from 'react';\nimport { randomIntFromInterval, reverseLinkedList, useInterval } from '../lib/utils.js';\nimport './Board.css';\n/**\n * TODO: add a more elegant UX for before a game starts and after a game ends.\n * A game probably shouldn't start until the user presses an arrow key, and\n * once a game is over, the board state should likely freeze until the user\n * intentionally restarts the game.\n */\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\n\nclass LinkedListNode {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n\n}\n\nclass LinkedList {\n  constructor(value) {\n    const node = new LinkedListNode(value);\n    this.head = node;\n    this.tail = node;\n  }\n\n}\n\nconst Direction = {\n  UP: 'UP',\n  RIGHT: 'RIGHT',\n  DOWN: 'DOWN',\n  LEFT: 'LEFT'\n};\nconst Speed = {\n  BEGINNER: 200,\n  INTERMEDIATE: 150,\n  PRO: 90\n};\nconst BOARD_SIZE = 15;\nconst PROBABILITY_OF_DIRECTION_REVERSAL_FOOD = 0.2;\n\nconst getStartingSnakeLLValue = board => {\n  const rowSize = board.length;\n  const colSize = board[0].length;\n  const startingRow = Math.round(rowSize / 3);\n  const startingCol = Math.round(colSize / 3);\n  const startingCell = board[startingRow][startingCol];\n  return {\n    row: startingRow,\n    col: startingCol,\n    cell: startingCell\n  };\n};\n\nconst starting = () => {\n  var _s = $RefreshSig$();\n\n  const Board = () => {\n    _s();\n\n    const [score, setScore] = useState(0);\n    const [board, setBoard] = useState(createBoard(BOARD_SIZE));\n    const [snake, setSnake] = useState(new LinkedList(getStartingSnakeLLValue(board)));\n    const [snakeCells, setSnakeCells] = useState(new Set([snake.head.value.cell]));\n    const [speed, setSpeed] = useState(Speed.BEGINNER); // Naively set the starting food cell 5 cells away from the starting snake cell.\n\n    const [foodCell, setFoodCell] = useState(snake.head.value.cell + 5);\n    const [direction, setDirection] = useState(Direction.RIGHT);\n    const [foodShouldReverseDirection, setFoodShouldReverseDirection] = useState(false);\n    useEffect(() => {\n      window.addEventListener('keydown', e => {\n        handleKeydown(e);\n      });\n    }, []); // `useInterval` is needed; you can't naively do `setInterval` in the\n    // `useEffect` above. See the article linked above the `useInterval`\n    // definition for details.\n\n    useInterval(() => {\n      moveSnake();\n    }, speed);\n\n    const handleKeydown = e => {\n      const newDirection = getDirectionFromKey(e.key);\n      const isValidDirection = newDirection !== '';\n      if (!isValidDirection) return;\n      const snakeWillRunIntoItself = getOppositeDirection(newDirection) === direction && snakeCells.size > 1; // Note: this functionality is currently broken, for the same reason that\n      // `useInterval` is needed. Specifically, the `direction` and `snakeCells`\n      // will currently never reflect their \"latest version\" when `handleKeydown`\n      // is called. I leave it as an exercise to the viewer to fix this :P\n\n      if (snakeWillRunIntoItself) return;\n      setDirection(newDirection);\n    };\n\n    const moveSnake = () => {\n      const currentHeadCoords = {\n        row: snake.head.value.row,\n        col: snake.head.value.col\n      };\n      const nextHeadCoords = getCoordsInDirection(currentHeadCoords, direction);\n\n      if (isOutOfBounds(nextHeadCoords, board)) {\n        handleGameOver();\n        return;\n      }\n\n      const nextHeadCell = board[nextHeadCoords.row][nextHeadCoords.col];\n\n      if (snakeCells.has(nextHeadCell)) {\n        handleGameOver();\n        return;\n      }\n\n      const newHead = new LinkedListNode({\n        row: nextHeadCoords.row,\n        col: nextHeadCoords.col,\n        cell: nextHeadCell\n      });\n      const currentHead = snake.head;\n      snake.head = newHead;\n      currentHead.next = newHead;\n      const newSnakeCells = new Set(snakeCells);\n      newSnakeCells.delete(snake.tail.value.cell);\n      newSnakeCells.add(nextHeadCell);\n      snake.tail = snake.tail.next;\n      if (snake.tail === null) snake.tail = snake.head;\n      const foodConsumed = nextHeadCell === foodCell;\n\n      if (foodConsumed) {\n        // This function mutates newSnakeCells.\n        growSnake(newSnakeCells);\n        if (foodShouldReverseDirection) reverseSnake();\n        handleFoodConsumption(newSnakeCells);\n      }\n\n      setSnakeCells(newSnakeCells);\n    }; // This function mutates newSnakeCells.\n\n\n    const growSnake = newSnakeCells => {\n      const growthNodeCoords = getGrowthNodeCoords(snake.tail, direction);\n\n      if (isOutOfBounds(growthNodeCoords, board)) {\n        // Snake is positioned such that it can't grow; don't do anything.\n        return;\n      }\n\n      const newTailCell = board[growthNodeCoords.row][growthNodeCoords.col];\n      const newTail = new LinkedListNode({\n        row: growthNodeCoords.row,\n        col: growthNodeCoords.col,\n        cell: newTailCell\n      });\n      const currentTail = snake.tail;\n      snake.tail = newTail;\n      snake.tail.next = currentTail;\n      newSnakeCells.add(newTailCell);\n    };\n\n    const reverseSnake = () => {\n      const tailNextNodeDirection = getNextNodeDirection(snake.tail, direction);\n      const newDirection = getOppositeDirection(tailNextNodeDirection);\n      setDirection(newDirection); // The tail of the snake is really the head of the linked list, which\n      // is why we have to pass the snake's tail to `reverseLinkedList`.\n\n      reverseLinkedList(snake.tail);\n      const snakeHead = snake.head;\n      snake.head = snake.tail;\n      snake.tail = snakeHead;\n    };\n\n    const handleFoodConsumption = newSnakeCells => {\n      const maxPossibleCellValue = BOARD_SIZE * BOARD_SIZE;\n      let nextFoodCell; // In practice, this will never be a time-consuming operation. Even\n      // in the extreme scenario where a snake is so big that it takes up 90%\n      // of the board (nearly impossible), there would be a 10% chance of generating\n      // a valid new food cell--so an average of 10 operations: trivial.\n\n      while (true) {\n        nextFoodCell = randomIntFromInterval(1, maxPossibleCellValue);\n        if (newSnakeCells.has(nextFoodCell) || foodCell === nextFoodCell) continue;\n        break;\n      }\n\n      const nextFoodShouldReverseDirection = Math.random() < PROBABILITY_OF_DIRECTION_REVERSAL_FOOD;\n      setFoodCell(nextFoodCell);\n      setFoodShouldReverseDirection(nextFoodShouldReverseDirection);\n      setScore(score + 1);\n    };\n\n    const handleGameOver = () => {\n      setScore(0);\n      const snakeLLStartingValue = getStartingSnakeLLValue(board);\n      setSnake(new LinkedList(snakeLLStartingValue));\n      setFoodCell(snakeLLStartingValue.cell + 5);\n      setSnakeCells(new Set([snakeLLStartingValue.cell]));\n      setDirection(Direction.RIGHT);\n    };\n\n    const handleChange = e => {\n      let value = e.target.value;\n\n      if (value == \"BEGINNER\") {\n        setSpeed(Speed.BEGINNER);\n      } else if (value == \"INTERMEDIATE\") {\n        setSpeed(Speed.INTERMEDIATE);\n      } else {\n        setSpeed(Speed.PRO);\n      }\n    };\n\n    return /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n          style: {\n            float: \"top\"\n          },\n          children: \"Choose level :\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 232,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            float: \"center\"\n          },\n          children: /*#__PURE__*/_jsxDEV(\"select\", {\n            className: \"level\",\n            onChange: e => handleChange(e),\n            disabled: false,\n            children: [/*#__PURE__*/_jsxDEV(\"option\", {\n              className: \"value\",\n              value: \"BEGINNER\",\n              children: \"Beginner\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 236,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n              className: \"value\",\n              value: \"INTERMEDIATE\",\n              children: \"Intermediate\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 237,\n              columnNumber: 15\n            }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n              className: \"value\",\n              value: \"PRO\",\n              children: \"Pro\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 238,\n              columnNumber: 15\n            }, this)]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 234,\n            columnNumber: 13\n          }, this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 233,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 231,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          paddingTop: \"10px\"\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"start\",\n          children: \"START\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 243,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          className: \"stop\",\n          onClick: () => handleGameOver(),\n          children: \"STOP\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 244,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 242,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"h2\", {\n        children: [\"Score: \", score]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 246,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"board\",\n        children: board.map((row, rowIdx) => /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"row\",\n          children: row.map((cellValue, cellIdx) => {\n            const className = getCellClassName(cellValue, foodCell, foodShouldReverseDirection, snakeCells);\n            return /*#__PURE__*/_jsxDEV(\"div\", {\n              className: className\n            }, cellIdx, false, {\n              fileName: _jsxFileName,\n              lineNumber: 257,\n              columnNumber: 24\n            }, this);\n          })\n        }, rowIdx, false, {\n          fileName: _jsxFileName,\n          lineNumber: 249,\n          columnNumber: 13\n        }, this))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 247,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true);\n  };\n\n  _s(Board, \"aL+fzfVyr+G54/iWv21RZBmmjZA=\", false, function () {\n    return [useInterval];\n  });\n};\n\nconst createBoard = BOARD_SIZE => {\n  let counter = 1;\n  const board = [];\n\n  for (let row = 0; row < BOARD_SIZE; row++) {\n    const currentRow = [];\n\n    for (let col = 0; col < BOARD_SIZE; col++) {\n      currentRow.push(counter++);\n    }\n\n    board.push(currentRow);\n  }\n\n  return board;\n};\n\nconst getCoordsInDirection = (coords, direction) => {\n  if (direction === Direction.UP) {\n    return {\n      row: coords.row - 1,\n      col: coords.col\n    };\n  }\n\n  if (direction === Direction.RIGHT) {\n    return {\n      row: coords.row,\n      col: coords.col + 1\n    };\n  }\n\n  if (direction === Direction.DOWN) {\n    return {\n      row: coords.row + 1,\n      col: coords.col\n    };\n  }\n\n  if (direction === Direction.LEFT) {\n    return {\n      row: coords.row,\n      col: coords.col - 1\n    };\n  }\n};\n\nconst isOutOfBounds = (coords, board) => {\n  const {\n    row,\n    col\n  } = coords;\n  if (row < 0 || col < 0) return true;\n  if (row >= board.length || col >= board[0].length) return true;\n  return false;\n};\n\nconst getDirectionFromKey = key => {\n  if (key === 'ArrowUp') return Direction.UP;\n  if (key === 'ArrowRight') return Direction.RIGHT;\n  if (key === 'ArrowDown') return Direction.DOWN;\n  if (key === 'ArrowLeft') return Direction.LEFT;\n  return '';\n};\n\nconst getNextNodeDirection = (node, currentDirection) => {\n  if (node.next === null) return currentDirection;\n  const {\n    row: currentRow,\n    col: currentCol\n  } = node.value;\n  const {\n    row: nextRow,\n    col: nextCol\n  } = node.next.value;\n\n  if (nextRow === currentRow && nextCol === currentCol + 1) {\n    return Direction.RIGHT;\n  }\n\n  if (nextRow === currentRow && nextCol === currentCol - 1) {\n    return Direction.LEFT;\n  }\n\n  if (nextCol === currentCol && nextRow === currentRow + 1) {\n    return Direction.DOWN;\n  }\n\n  if (nextCol === currentCol && nextRow === currentRow - 1) {\n    return Direction.UP;\n  }\n\n  return '';\n};\n\nconst getGrowthNodeCoords = (snakeTail, currentDirection) => {\n  const tailNextNodeDirection = getNextNodeDirection(snakeTail, currentDirection);\n  const growthDirection = getOppositeDirection(tailNextNodeDirection);\n  const currentTailCoords = {\n    row: snakeTail.value.row,\n    col: snakeTail.value.col\n  };\n  const growthNodeCoords = getCoordsInDirection(currentTailCoords, growthDirection);\n  return growthNodeCoords;\n};\n\nconst getOppositeDirection = direction => {\n  if (direction === Direction.UP) return Direction.DOWN;\n  if (direction === Direction.RIGHT) return Direction.LEFT;\n  if (direction === Direction.DOWN) return Direction.UP;\n  if (direction === Direction.LEFT) return Direction.RIGHT;\n};\n\nconst getCellClassName = (cellValue, foodCell, foodShouldReverseDirection, snakeCells) => {\n  let className = 'cell';\n\n  if (cellValue === foodCell) {\n    if (foodShouldReverseDirection) {\n      className = 'cell cell-purple';\n    } else {\n      className = 'cell cell-red';\n    }\n  }\n\n  if (snakeCells.has(cellValue)) className = 'cell cell-green';\n  return className;\n};\n\nexport default Board;","map":{"version":3,"sources":["/home/anjali/Desktop/Snake Game/src/Board/Board.jsx"],"names":["React","useEffect","useState","randomIntFromInterval","reverseLinkedList","useInterval","LinkedListNode","constructor","value","next","LinkedList","node","head","tail","Direction","UP","RIGHT","DOWN","LEFT","Speed","BEGINNER","INTERMEDIATE","PRO","BOARD_SIZE","PROBABILITY_OF_DIRECTION_REVERSAL_FOOD","getStartingSnakeLLValue","board","rowSize","length","colSize","startingRow","Math","round","startingCol","startingCell","row","col","cell","starting","Board","score","setScore","setBoard","createBoard","snake","setSnake","snakeCells","setSnakeCells","Set","speed","setSpeed","foodCell","setFoodCell","direction","setDirection","foodShouldReverseDirection","setFoodShouldReverseDirection","window","addEventListener","e","handleKeydown","moveSnake","newDirection","getDirectionFromKey","key","isValidDirection","snakeWillRunIntoItself","getOppositeDirection","size","currentHeadCoords","nextHeadCoords","getCoordsInDirection","isOutOfBounds","handleGameOver","nextHeadCell","has","newHead","currentHead","newSnakeCells","delete","add","foodConsumed","growSnake","reverseSnake","handleFoodConsumption","growthNodeCoords","getGrowthNodeCoords","newTailCell","newTail","currentTail","tailNextNodeDirection","getNextNodeDirection","snakeHead","maxPossibleCellValue","nextFoodCell","nextFoodShouldReverseDirection","random","snakeLLStartingValue","handleChange","target","float","paddingTop","map","rowIdx","cellValue","cellIdx","className","getCellClassName","counter","currentRow","push","coords","currentDirection","currentCol","nextRow","nextCol","snakeTail","growthDirection","currentTailCoords"],"mappings":"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","sourcesContent":["import React, { useEffect, useState } from 'react';\nimport {\n  randomIntFromInterval,\n  reverseLinkedList,\n  useInterval,\n} from '../lib/utils.js';\n\nimport './Board.css';\n\n/**\n * TODO: add a more elegant UX for before a game starts and after a game ends.\n * A game probably shouldn't start until the user presses an arrow key, and\n * once a game is over, the board state should likely freeze until the user\n * intentionally restarts the game.\n */\n\nclass LinkedListNode {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nclass LinkedList {\n  constructor(value) {\n    const node = new LinkedListNode(value);\n    this.head = node;\n    this.tail = node;\n  }\n}\n\nconst Direction = {\n  UP: 'UP',\n  RIGHT: 'RIGHT',\n  DOWN: 'DOWN',\n  LEFT: 'LEFT',\n};\n\nconst Speed = {\n  BEGINNER: 200,\n  INTERMEDIATE: 150,\n  PRO: 90\n};\n\nconst BOARD_SIZE = 15;\nconst PROBABILITY_OF_DIRECTION_REVERSAL_FOOD = 0.2;\n\nconst getStartingSnakeLLValue = board => {\n  const rowSize = board.length;\n  const colSize = board[0].length;\n  const startingRow = Math.round(rowSize / 3);\n  const startingCol = Math.round(colSize / 3);\n  const startingCell = board[startingRow][startingCol];\n\n  return {\n    row: startingRow,\n    col: startingCol,\n    cell: startingCell,\n  };\n};\nconst starting=()=>{\n  const Board = () => {\n    const [score, setScore] = useState(0);\n    const [board, setBoard] = useState(createBoard(BOARD_SIZE));\n    const [snake, setSnake] = useState(\n      new LinkedList(getStartingSnakeLLValue(board)),\n    );\n    const [snakeCells, setSnakeCells] = useState(\n      new Set([snake.head.value.cell]),\n    );\n    const [speed, setSpeed] = useState(Speed.BEGINNER);\n  \n    // Naively set the starting food cell 5 cells away from the starting snake cell.\n    const [foodCell, setFoodCell] = useState(snake.head.value.cell + 5);\n    const [direction, setDirection] = useState(Direction.RIGHT);\n    const [foodShouldReverseDirection, setFoodShouldReverseDirection] = useState(\n      false,\n    );\n  \n    useEffect(() => {\n      window.addEventListener('keydown', e => {\n        handleKeydown(e);\n      });\n    }, []);\n  \n    // `useInterval` is needed; you can't naively do `setInterval` in the\n    // `useEffect` above. See the article linked above the `useInterval`\n    // definition for details.\n    useInterval(() => {\n  \n      moveSnake();\n    }, speed);\n  \n    const handleKeydown = e => {\n      const newDirection = getDirectionFromKey(e.key);\n      const isValidDirection = newDirection !== '';\n      if (!isValidDirection) return;\n      const snakeWillRunIntoItself =\n        getOppositeDirection(newDirection) === direction && snakeCells.size > 1;\n      // Note: this functionality is currently broken, for the same reason that\n      // `useInterval` is needed. Specifically, the `direction` and `snakeCells`\n      // will currently never reflect their \"latest version\" when `handleKeydown`\n      // is called. I leave it as an exercise to the viewer to fix this :P\n      if (snakeWillRunIntoItself) return;\n      setDirection(newDirection);\n    };\n  \n    const moveSnake = () => {\n      const currentHeadCoords = {\n        row: snake.head.value.row,\n        col: snake.head.value.col,\n      };\n  \n      const nextHeadCoords = getCoordsInDirection(currentHeadCoords, direction);\n      if (isOutOfBounds(nextHeadCoords, board)) {\n        handleGameOver();\n        return;\n      }\n      const nextHeadCell = board[nextHeadCoords.row][nextHeadCoords.col];\n      if (snakeCells.has(nextHeadCell)) {\n        handleGameOver();\n        return;\n      }\n  \n      const newHead = new LinkedListNode({\n        row: nextHeadCoords.row,\n        col: nextHeadCoords.col,\n        cell: nextHeadCell,\n      });\n      const currentHead = snake.head;\n      snake.head = newHead;\n      currentHead.next = newHead;\n  \n      const newSnakeCells = new Set(snakeCells);\n      newSnakeCells.delete(snake.tail.value.cell);\n      newSnakeCells.add(nextHeadCell);\n  \n      snake.tail = snake.tail.next;\n      if (snake.tail === null) snake.tail = snake.head;\n  \n      const foodConsumed = nextHeadCell === foodCell;\n      if (foodConsumed) {\n        // This function mutates newSnakeCells.\n        growSnake(newSnakeCells);\n        if (foodShouldReverseDirection) reverseSnake();\n        handleFoodConsumption(newSnakeCells);\n      }\n  \n      setSnakeCells(newSnakeCells);\n    };\n  \n    // This function mutates newSnakeCells.\n    const growSnake = newSnakeCells => {\n      const growthNodeCoords = getGrowthNodeCoords(snake.tail, direction);\n      if (isOutOfBounds(growthNodeCoords, board)) {\n        // Snake is positioned such that it can't grow; don't do anything.\n        return;\n      }\n      const newTailCell = board[growthNodeCoords.row][growthNodeCoords.col];\n      const newTail = new LinkedListNode({\n        row: growthNodeCoords.row,\n        col: growthNodeCoords.col,\n        cell: newTailCell,\n      });\n      const currentTail = snake.tail;\n      snake.tail = newTail;\n      snake.tail.next = currentTail;\n  \n      newSnakeCells.add(newTailCell);\n    };\n  \n    const reverseSnake = () => {\n      const tailNextNodeDirection = getNextNodeDirection(snake.tail, direction);\n      const newDirection = getOppositeDirection(tailNextNodeDirection);\n      setDirection(newDirection);\n  \n      // The tail of the snake is really the head of the linked list, which\n      // is why we have to pass the snake's tail to `reverseLinkedList`.\n      reverseLinkedList(snake.tail);\n      const snakeHead = snake.head;\n      snake.head = snake.tail;\n      snake.tail = snakeHead;\n    };\n  \n    const handleFoodConsumption = newSnakeCells => {\n      const maxPossibleCellValue = BOARD_SIZE * BOARD_SIZE;\n      let nextFoodCell;\n      // In practice, this will never be a time-consuming operation. Even\n      // in the extreme scenario where a snake is so big that it takes up 90%\n      // of the board (nearly impossible), there would be a 10% chance of generating\n      // a valid new food cell--so an average of 10 operations: trivial.\n      while (true) {\n        nextFoodCell = randomIntFromInterval(1, maxPossibleCellValue);\n        if (newSnakeCells.has(nextFoodCell) || foodCell === nextFoodCell)\n          continue;\n        break;\n      }\n  \n      const nextFoodShouldReverseDirection =\n        Math.random() < PROBABILITY_OF_DIRECTION_REVERSAL_FOOD;\n  \n      setFoodCell(nextFoodCell);\n      setFoodShouldReverseDirection(nextFoodShouldReverseDirection);\n      setScore(score + 1);\n    };\n  \n    const handleGameOver = () => {\n      setScore(0);\n      const snakeLLStartingValue = getStartingSnakeLLValue(board);\n      setSnake(new LinkedList(snakeLLStartingValue));\n      setFoodCell(snakeLLStartingValue.cell + 5);\n      setSnakeCells(new Set([snakeLLStartingValue.cell]));\n      setDirection(Direction.RIGHT);\n    };\n    const handleChange = (e) => {\n      let value = e.target.value;\n      if (value == \"BEGINNER\") {\n        setSpeed(Speed.BEGINNER);\n  \n      }\n      else if (value == \"INTERMEDIATE\") {\n        setSpeed(Speed.INTERMEDIATE)\n      }\n      else {\n        setSpeed(Speed.PRO)\n      }\n  \n    };\n    return (\n      <>\n        <div>\n          <h3 style={{ float: \"top\" }}>Choose level :</h3>\n          <div style={{ float: \"center\" }} >\n            <select className=\"level\"\n              onChange={(e) => handleChange(e)} disabled={false}>\n              <option className=\"value\" value=\"BEGINNER\">Beginner</option>\n              <option className=\"value\" value=\"INTERMEDIATE\">Intermediate</option>\n              <option className=\"value\" value=\"PRO\">Pro</option>\n            </select>\n          </div>\n        </div>\n        <div style={{ paddingTop: \"10px\" }}>\n          <button className=\"start\" >START</button>\n          <button className=\"stop\" onClick={() => handleGameOver()} >STOP</button>\n        </div>\n        <h2>Score: {score}</h2>\n        <div className=\"board\">\n          {board.map((row, rowIdx) => (\n            <div key={rowIdx} className=\"row\">\n              {row.map((cellValue, cellIdx) => {\n                const className = getCellClassName(\n                  cellValue,\n                  foodCell,\n                  foodShouldReverseDirection,\n                  snakeCells,\n                );\n                return <div key={cellIdx} className={className}></div>;\n              })}\n            </div>\n          ))}\n        </div>\n      </>\n    );\n  };\n}\n\n\nconst createBoard = BOARD_SIZE => {\n  let counter = 1;\n  const board = [];\n  for (let row = 0; row < BOARD_SIZE; row++) {\n    const currentRow = [];\n    for (let col = 0; col < BOARD_SIZE; col++) {\n      currentRow.push(counter++);\n    }\n    board.push(currentRow);\n  }\n  return board;\n};\n\nconst getCoordsInDirection = (coords, direction) => {\n  if (direction === Direction.UP) {\n    return {\n      row: coords.row - 1,\n      col: coords.col,\n    };\n  }\n  if (direction === Direction.RIGHT) {\n    return {\n      row: coords.row,\n      col: coords.col + 1,\n    };\n  }\n  if (direction === Direction.DOWN) {\n    return {\n      row: coords.row + 1,\n      col: coords.col,\n    };\n  }\n  if (direction === Direction.LEFT) {\n    return {\n      row: coords.row,\n      col: coords.col - 1,\n    };\n  }\n};\n\nconst isOutOfBounds = (coords, board) => {\n  const { row, col } = coords;\n  if (row < 0 || col < 0) return true;\n  if (row >= board.length || col >= board[0].length) return true;\n  return false;\n};\n\nconst getDirectionFromKey = key => {\n  if (key === 'ArrowUp') return Direction.UP;\n  if (key === 'ArrowRight') return Direction.RIGHT;\n  if (key === 'ArrowDown') return Direction.DOWN;\n  if (key === 'ArrowLeft') return Direction.LEFT;\n  return '';\n};\n\nconst getNextNodeDirection = (node, currentDirection) => {\n  if (node.next === null) return currentDirection;\n  const { row: currentRow, col: currentCol } = node.value;\n  const { row: nextRow, col: nextCol } = node.next.value;\n  if (nextRow === currentRow && nextCol === currentCol + 1) {\n    return Direction.RIGHT;\n  }\n  if (nextRow === currentRow && nextCol === currentCol - 1) {\n    return Direction.LEFT;\n  }\n  if (nextCol === currentCol && nextRow === currentRow + 1) {\n    return Direction.DOWN;\n  }\n  if (nextCol === currentCol && nextRow === currentRow - 1) {\n    return Direction.UP;\n  }\n  return '';\n};\n\nconst getGrowthNodeCoords = (snakeTail, currentDirection) => {\n  const tailNextNodeDirection = getNextNodeDirection(\n    snakeTail,\n    currentDirection,\n  );\n  const growthDirection = getOppositeDirection(tailNextNodeDirection);\n  const currentTailCoords = {\n    row: snakeTail.value.row,\n    col: snakeTail.value.col,\n  };\n  const growthNodeCoords = getCoordsInDirection(\n    currentTailCoords,\n    growthDirection,\n  );\n  return growthNodeCoords;\n};\n\nconst getOppositeDirection = direction => {\n  if (direction === Direction.UP) return Direction.DOWN;\n  if (direction === Direction.RIGHT) return Direction.LEFT;\n  if (direction === Direction.DOWN) return Direction.UP;\n  if (direction === Direction.LEFT) return Direction.RIGHT;\n};\n\nconst getCellClassName = (\n  cellValue,\n  foodCell,\n  foodShouldReverseDirection,\n  snakeCells,\n) => {\n  let className = 'cell';\n  if (cellValue === foodCell) {\n    if (foodShouldReverseDirection) {\n      className = 'cell cell-purple';\n    } else {\n      className = 'cell cell-red';\n    }\n  }\n  if (snakeCells.has(cellValue)) className = 'cell cell-green';\n\n  return className;\n};\n\nexport default Board;\n"]},"metadata":{},"sourceType":"module"}