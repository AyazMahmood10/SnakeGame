{"ast":null,"code":"import _slicedToArray from\"/home/ayaz/career_projects/SnakeGame/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _classCallCheck from\"/home/ayaz/career_projects/SnakeGame/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import React,{useEffect,useState}from'react';import{randomIntFromInterval,reverseLinkedList,useInterval}from'../lib/utils.js';import'./Board.css';/**\n * TODO: add a more elegant UX for before a game starts and after a game ends.\n * A game probably shouldn't start until the user presses an arrow key, and\n * once a game is over, the board state should likely freeze until the user\n * intentionally restarts the game.\n */import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";import{Fragment as _Fragment}from\"react/jsx-runtime\";var LinkedListNode=function LinkedListNode(value){_classCallCheck(this,LinkedListNode);this.value=value;this.next=null;};var LinkedList=function LinkedList(value){_classCallCheck(this,LinkedList);var node=new LinkedListNode(value);this.head=node;this.tail=node;};var Direction={UP:'UP',RIGHT:'RIGHT',DOWN:'DOWN',LEFT:'LEFT'};var Speed={BEGINNER:200,INTERMEDIATE:150,PRO:90};var BOARD_SIZE=15;var PROBABILITY_OF_DIRECTION_REVERSAL_FOOD=0.2;var getStartingSnakeLLValue=function getStartingSnakeLLValue(board){var rowSize=board.length;var colSize=board[0].length;var startingRow=Math.round(rowSize/3);var startingCol=Math.round(colSize/3);var startingCell=board[startingRow][startingCol];return{row:startingRow,col:startingCol,cell:startingCell};};console.log(\"hello\");var Board=function Board(){console.log(\"inside Board\");var _useState=useState(0),_useState2=_slicedToArray(_useState,2),score=_useState2[0],setScore=_useState2[1];var _useState3=useState(createBoard(BOARD_SIZE)),_useState4=_slicedToArray(_useState3,2),board=_useState4[0],setBoard=_useState4[1];var _useState5=useState(new LinkedList(getStartingSnakeLLValue(board))),_useState6=_slicedToArray(_useState5,2),snake=_useState6[0],setSnake=_useState6[1];var _useState7=useState(new Set([snake.head.value.cell])),_useState8=_slicedToArray(_useState7,2),snakeCells=_useState8[0],setSnakeCells=_useState8[1];var _useState9=useState(Speed.BEGINNER),_useState10=_slicedToArray(_useState9,2),speed=_useState10[0],setSpeed=_useState10[1];// Naively set the starting food cell 5 cells away from the starting snake cell.\nvar _useState11=useState(snake.head.value.cell+5),_useState12=_slicedToArray(_useState11,2),foodCell=_useState12[0],setFoodCell=_useState12[1];var _useState13=useState(Direction.RIGHT),_useState14=_slicedToArray(_useState13,2),direction=_useState14[0],setDirection=_useState14[1];var _useState15=useState(false),_useState16=_slicedToArray(_useState15,2),foodShouldReverseDirection=_useState16[0],setFoodShouldReverseDirection=_useState16[1];useEffect(function(){window.addEventListener('keydown',function(e){handleKeydown(e);});},[]);useInterval(function(){moveSnake();},speed);// `useInterval` is needed; you can't naively do `setInterval` in the\n// `useEffect` above. See the article linked above the `useInterval`\n// definition for details.\nvar handleKeydown=function handleKeydown(e){var newDirection=getDirectionFromKey(e.key);var isValidDirection=newDirection!=='';if(!isValidDirection)return;var snakeWillRunIntoItself=getOppositeDirection(newDirection)===direction&&snakeCells.size>1;// Note: this functionality is currently broken, for the same reason that\n// `useInterval` is needed. Specifically, the `direction` and `snakeCells`\n// will currently never reflect their \"latest version\" when `handleKeydown`\n// is called. I leave it as an exercise to the viewer to fix this :P\nif(snakeWillRunIntoItself)return;setDirection(newDirection);};var moveSnake=function moveSnake(){var currentHeadCoords={row:snake.head.value.row,col:snake.head.value.col};var nextHeadCoords=getCoordsInDirection(currentHeadCoords,direction);if(isOutOfBounds(nextHeadCoords,board)){handleGameOver();return;}var nextHeadCell=board[nextHeadCoords.row][nextHeadCoords.col];if(snakeCells.has(nextHeadCell)){handleGameOver();return;}var newHead=new LinkedListNode({row:nextHeadCoords.row,col:nextHeadCoords.col,cell:nextHeadCell});var currentHead=snake.head;snake.head=newHead;currentHead.next=newHead;var newSnakeCells=new Set(snakeCells);newSnakeCells.delete(snake.tail.value.cell);newSnakeCells.add(nextHeadCell);snake.tail=snake.tail.next;if(snake.tail===null)snake.tail=snake.head;var foodConsumed=nextHeadCell===foodCell;if(foodConsumed){// This function mutates newSnakeCells.\ngrowSnake(newSnakeCells);if(foodShouldReverseDirection)reverseSnake();handleFoodConsumption(newSnakeCells);}setSnakeCells(newSnakeCells);};// This function mutates newSnakeCells.\nvar growSnake=function growSnake(newSnakeCells){var growthNodeCoords=getGrowthNodeCoords(snake.tail,direction);if(isOutOfBounds(growthNodeCoords,board)){// Snake is positioned such that it can't grow; don't do anything.\nreturn;}var newTailCell=board[growthNodeCoords.row][growthNodeCoords.col];var newTail=new LinkedListNode({row:growthNodeCoords.row,col:growthNodeCoords.col,cell:newTailCell});var currentTail=snake.tail;snake.tail=newTail;snake.tail.next=currentTail;newSnakeCells.add(newTailCell);};var reverseSnake=function reverseSnake(){var tailNextNodeDirection=getNextNodeDirection(snake.tail,direction);var newDirection=getOppositeDirection(tailNextNodeDirection);setDirection(newDirection);// The tail of the snake is really the head of the linked list, which\n// is why we have to pass the snake's tail to `reverseLinkedList`.\nreverseLinkedList(snake.tail);var snakeHead=snake.head;snake.head=snake.tail;snake.tail=snakeHead;};var handleFoodConsumption=function handleFoodConsumption(newSnakeCells){var maxPossibleCellValue=BOARD_SIZE*BOARD_SIZE;var nextFoodCell;// In practice, this will never be a time-consuming operation. Even\n// in the extreme scenario where a snake is so big that it takes up 90%\n// of the board (nearly impossible), there would be a 10% chance of generating\n// a valid new food cell--so an average of 10 operations: trivial.\nwhile(true){nextFoodCell=randomIntFromInterval(1,maxPossibleCellValue);if(newSnakeCells.has(nextFoodCell)||foodCell===nextFoodCell)continue;break;}var nextFoodShouldReverseDirection=Math.random()<PROBABILITY_OF_DIRECTION_REVERSAL_FOOD;setFoodCell(nextFoodCell);setFoodShouldReverseDirection(nextFoodShouldReverseDirection);setScore(score+1);};var handleGameOver=function handleGameOver(){setScore(0);var snakeLLStartingValue=getStartingSnakeLLValue(board);setSnake(new LinkedList(snakeLLStartingValue));setFoodCell(snakeLLStartingValue.cell+5);setSnakeCells(new Set([snakeLLStartingValue.cell]));setDirection(Direction.RIGHT);};var handleChange=function handleChange(e){var value=e.target.value;if(value===\"BEGINNER\"){setSpeed(Speed.BEGINNER);}else if(value===\"INTERMEDIATE\"){setSpeed(Speed.INTERMEDIATE);}else{setSpeed(Speed.PRO);}};return/*#__PURE__*/_jsxs(_Fragment,{children:[/*#__PURE__*/_jsxs(\"div\",{children:[/*#__PURE__*/_jsx(\"h3\",{style:{float:\"top\"},children:\"Choose level :\"}),/*#__PURE__*/_jsx(\"div\",{style:{float:\"center\"},children:/*#__PURE__*/_jsxs(\"select\",{className:\"level\",onChange:function onChange(e){return handleChange(e);},disabled:false,children:[/*#__PURE__*/_jsx(\"option\",{className:\"value\",value:\"BEGINNER\",children:\"Beginner\"}),/*#__PURE__*/_jsx(\"option\",{className:\"value\",value:\"INTERMEDIATE\",children:\"Intermediate\"}),/*#__PURE__*/_jsx(\"option\",{className:\"value\",value:\"PRO\",children:\"Pro\"})]})})]}),/*#__PURE__*/_jsxs(\"div\",{style:{paddingTop:\"10px\"},children:[/*#__PURE__*/_jsx(\"button\",{className:\"start\",children:\"START\"}),/*#__PURE__*/_jsx(\"button\",{className:\"stop\",onClick:function onClick(){return handleGameOver();},children:\"STOP\"})]}),/*#__PURE__*/_jsxs(\"h2\",{children:[\"Score: \",score]}),/*#__PURE__*/_jsx(\"div\",{className:\"board\",children:board.map(function(row,rowIdx){return/*#__PURE__*/_jsx(\"div\",{className:\"row\",children:row.map(function(cellValue,cellIdx){var className=getCellClassName(cellValue,foodCell,foodShouldReverseDirection,snakeCells);return/*#__PURE__*/_jsx(\"div\",{className:className},cellIdx);})},rowIdx);})})]});};var createBoard=function createBoard(BOARD_SIZE){var counter=1;var board=[];for(var row=0;row<BOARD_SIZE;row++){var currentRow=[];for(var col=0;col<BOARD_SIZE;col++){currentRow.push(counter++);}board.push(currentRow);}return board;};var getCoordsInDirection=function getCoordsInDirection(coords,direction){if(direction===Direction.UP){return{row:coords.row-1,col:coords.col};}if(direction===Direction.RIGHT){return{row:coords.row,col:coords.col+1};}if(direction===Direction.DOWN){return{row:coords.row+1,col:coords.col};}if(direction===Direction.LEFT){return{row:coords.row,col:coords.col-1};}};var isOutOfBounds=function isOutOfBounds(coords,board){var row=coords.row,col=coords.col;if(row<0||col<0)return true;if(row>=board.length||col>=board[0].length)return true;return false;};var getDirectionFromKey=function getDirectionFromKey(key){if(key==='ArrowUp')return Direction.UP;if(key==='ArrowRight')return Direction.RIGHT;if(key==='ArrowDown')return Direction.DOWN;if(key==='ArrowLeft')return Direction.LEFT;return'';};var getNextNodeDirection=function getNextNodeDirection(node,currentDirection){if(node.next===null)return currentDirection;var _node$value=node.value,currentRow=_node$value.row,currentCol=_node$value.col;var _node$next$value=node.next.value,nextRow=_node$next$value.row,nextCol=_node$next$value.col;if(nextRow===currentRow&&nextCol===currentCol+1){return Direction.RIGHT;}if(nextRow===currentRow&&nextCol===currentCol-1){return Direction.LEFT;}if(nextCol===currentCol&&nextRow===currentRow+1){return Direction.DOWN;}if(nextCol===currentCol&&nextRow===currentRow-1){return Direction.UP;}return'';};var getGrowthNodeCoords=function getGrowthNodeCoords(snakeTail,currentDirection){var tailNextNodeDirection=getNextNodeDirection(snakeTail,currentDirection);var growthDirection=getOppositeDirection(tailNextNodeDirection);var currentTailCoords={row:snakeTail.value.row,col:snakeTail.value.col};var growthNodeCoords=getCoordsInDirection(currentTailCoords,growthDirection);return growthNodeCoords;};var getOppositeDirection=function getOppositeDirection(direction){if(direction===Direction.UP)return Direction.DOWN;if(direction===Direction.RIGHT)return Direction.LEFT;if(direction===Direction.DOWN)return Direction.UP;if(direction===Direction.LEFT)return Direction.RIGHT;};var getCellClassName=function getCellClassName(cellValue,foodCell,foodShouldReverseDirection,snakeCells){var className='cell';if(cellValue===foodCell){if(foodShouldReverseDirection){className='cell cell-purple';}else{className='cell cell-red';}}if(snakeCells.has(cellValue))className='cell cell-green';return className;};export default Board;","map":{"version":3,"sources":["/home/ayaz/career_projects/SnakeGame/src/Board/Board.jsx"],"names":["React","useEffect","useState","randomIntFromInterval","reverseLinkedList","useInterval","LinkedListNode","value","next","LinkedList","node","head","tail","Direction","UP","RIGHT","DOWN","LEFT","Speed","BEGINNER","INTERMEDIATE","PRO","BOARD_SIZE","PROBABILITY_OF_DIRECTION_REVERSAL_FOOD","getStartingSnakeLLValue","board","rowSize","length","colSize","startingRow","Math","round","startingCol","startingCell","row","col","cell","console","log","Board","score","setScore","createBoard","setBoard","snake","setSnake","Set","snakeCells","setSnakeCells","speed","setSpeed","foodCell","setFoodCell","direction","setDirection","foodShouldReverseDirection","setFoodShouldReverseDirection","window","addEventListener","e","handleKeydown","moveSnake","newDirection","getDirectionFromKey","key","isValidDirection","snakeWillRunIntoItself","getOppositeDirection","size","currentHeadCoords","nextHeadCoords","getCoordsInDirection","isOutOfBounds","handleGameOver","nextHeadCell","has","newHead","currentHead","newSnakeCells","delete","add","foodConsumed","growSnake","reverseSnake","handleFoodConsumption","growthNodeCoords","getGrowthNodeCoords","newTailCell","newTail","currentTail","tailNextNodeDirection","getNextNodeDirection","snakeHead","maxPossibleCellValue","nextFoodCell","nextFoodShouldReverseDirection","random","snakeLLStartingValue","handleChange","target","float","paddingTop","map","rowIdx","cellValue","cellIdx","className","getCellClassName","counter","currentRow","push","coords","currentDirection","currentCol","nextRow","nextCol","snakeTail","growthDirection","currentTailCoords"],"mappings":"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","sourcesContent":["import React, { useEffect, useState } from 'react';\nimport {\n  randomIntFromInterval,\n  reverseLinkedList,\n  useInterval,\n} from '../lib/utils.js';\n\nimport './Board.css';\n\n/**\n * TODO: add a more elegant UX for before a game starts and after a game ends.\n * A game probably shouldn't start until the user presses an arrow key, and\n * once a game is over, the board state should likely freeze until the user\n * intentionally restarts the game.\n */\n\nclass LinkedListNode {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nclass LinkedList {\n  constructor(value) {\n    const node = new LinkedListNode(value);\n    this.head = node;\n    this.tail = node;\n  }\n}\n\nconst Direction = {\n  UP: 'UP',\n  RIGHT: 'RIGHT',\n  DOWN: 'DOWN',\n  LEFT: 'LEFT',\n};\n\nconst Speed = {\n  BEGINNER: 200,\n  INTERMEDIATE: 150,\n  PRO: 90\n};\n\nconst BOARD_SIZE = 15;\nconst PROBABILITY_OF_DIRECTION_REVERSAL_FOOD = 0.2;\n\nconst getStartingSnakeLLValue = board => {\n  const rowSize = board.length;\n  const colSize = board[0].length;\n  const startingRow = Math.round(rowSize / 3);\n  const startingCol = Math.round(colSize / 3);\n  const startingCell = board[startingRow][startingCol];\n\n  return {\n    row: startingRow,\n    col: startingCol,\n    cell: startingCell,\n  };\n};\n\nconsole.log(\"hello\");\nconst Board = () => {\n  console.log(\"inside Board\")\n  const [score, setScore] = useState(0);\n  const [board, setBoard] = useState(createBoard(BOARD_SIZE));\n  const [snake, setSnake] = useState(\n    new LinkedList(getStartingSnakeLLValue(board)),\n  );\n  const [snakeCells, setSnakeCells] = useState(\n    new Set([snake.head.value.cell]),\n  );\n  const [speed, setSpeed] = useState(Speed.BEGINNER);\n\n  // Naively set the starting food cell 5 cells away from the starting snake cell.\n  const [foodCell, setFoodCell] = useState(snake.head.value.cell + 5);\n  const [direction, setDirection] = useState(Direction.RIGHT);\n  const [foodShouldReverseDirection, setFoodShouldReverseDirection] = useState(\n    false,\n  );\n  \n\n  useEffect(() => {\n    window.addEventListener('keydown', e => {\n      handleKeydown(e);\n    });\n  }, []);\n  useInterval(() => {\n\n    moveSnake();\n  }, speed);\n\n  // `useInterval` is needed; you can't naively do `setInterval` in the\n  // `useEffect` above. See the article linked above the `useInterval`\n  // definition for details.\n\n  const handleKeydown = e => {\n    const newDirection = getDirectionFromKey(e.key);\n    const isValidDirection = newDirection !== '';\n    if (!isValidDirection) return;\n    const snakeWillRunIntoItself =\n      getOppositeDirection(newDirection) === direction && snakeCells.size > 1;\n    // Note: this functionality is currently broken, for the same reason that\n    // `useInterval` is needed. Specifically, the `direction` and `snakeCells`\n    // will currently never reflect their \"latest version\" when `handleKeydown`\n    // is called. I leave it as an exercise to the viewer to fix this :P\n    if (snakeWillRunIntoItself) return;\n    setDirection(newDirection);\n  };\n\n  const moveSnake = () => {\n    const currentHeadCoords = {\n      row: snake.head.value.row,\n      col: snake.head.value.col,\n    };\n\n    const nextHeadCoords = getCoordsInDirection(currentHeadCoords, direction);\n    if (isOutOfBounds(nextHeadCoords, board)) {\n      handleGameOver();\n      return;\n    }\n    const nextHeadCell = board[nextHeadCoords.row][nextHeadCoords.col];\n    if (snakeCells.has(nextHeadCell)) {\n      handleGameOver();\n      return;\n    }\n\n    const newHead = new LinkedListNode({\n      row: nextHeadCoords.row,\n      col: nextHeadCoords.col,\n      cell: nextHeadCell,\n    });\n    const currentHead = snake.head;\n    snake.head = newHead;\n    currentHead.next = newHead;\n\n    const newSnakeCells = new Set(snakeCells);\n    newSnakeCells.delete(snake.tail.value.cell);\n    newSnakeCells.add(nextHeadCell);\n\n    snake.tail = snake.tail.next;\n    if (snake.tail === null) snake.tail = snake.head;\n\n    const foodConsumed = nextHeadCell === foodCell;\n    if (foodConsumed) {\n      // This function mutates newSnakeCells.\n      growSnake(newSnakeCells);\n      if (foodShouldReverseDirection) reverseSnake();\n      handleFoodConsumption(newSnakeCells);\n    }\n\n    setSnakeCells(newSnakeCells);\n  };\n\n  // This function mutates newSnakeCells.\n  const growSnake = newSnakeCells => {\n    const growthNodeCoords = getGrowthNodeCoords(snake.tail, direction);\n    if (isOutOfBounds(growthNodeCoords, board)) {\n      // Snake is positioned such that it can't grow; don't do anything.\n      return;\n    }\n    const newTailCell = board[growthNodeCoords.row][growthNodeCoords.col];\n    const newTail = new LinkedListNode({\n      row: growthNodeCoords.row,\n      col: growthNodeCoords.col,\n      cell: newTailCell,\n    });\n    const currentTail = snake.tail;\n    snake.tail = newTail;\n    snake.tail.next = currentTail;\n\n    newSnakeCells.add(newTailCell);\n  };\n\n  const reverseSnake = () => {\n    const tailNextNodeDirection = getNextNodeDirection(snake.tail, direction);\n    const newDirection = getOppositeDirection(tailNextNodeDirection);\n    setDirection(newDirection);\n\n    // The tail of the snake is really the head of the linked list, which\n    // is why we have to pass the snake's tail to `reverseLinkedList`.\n    reverseLinkedList(snake.tail);\n    const snakeHead = snake.head;\n    snake.head = snake.tail;\n    snake.tail = snakeHead;\n  };\n\n  const handleFoodConsumption = newSnakeCells => {\n    const maxPossibleCellValue = BOARD_SIZE * BOARD_SIZE;\n    let nextFoodCell;\n    // In practice, this will never be a time-consuming operation. Even\n    // in the extreme scenario where a snake is so big that it takes up 90%\n    // of the board (nearly impossible), there would be a 10% chance of generating\n    // a valid new food cell--so an average of 10 operations: trivial.\n    while (true) {\n      nextFoodCell = randomIntFromInterval(1, maxPossibleCellValue);\n      if (newSnakeCells.has(nextFoodCell) || foodCell === nextFoodCell)\n        continue;\n      break;\n    }\n\n    const nextFoodShouldReverseDirection =\n      Math.random() < PROBABILITY_OF_DIRECTION_REVERSAL_FOOD;\n\n    setFoodCell(nextFoodCell);\n    setFoodShouldReverseDirection(nextFoodShouldReverseDirection);\n    setScore(score + 1);\n  };\n\n  const handleGameOver = () => {\n    setScore(0);\n    const snakeLLStartingValue = getStartingSnakeLLValue(board);\n    setSnake(new LinkedList(snakeLLStartingValue));\n    setFoodCell(snakeLLStartingValue.cell + 5);\n    setSnakeCells(new Set([snakeLLStartingValue.cell]));\n    setDirection(Direction.RIGHT);\n  };\n  const handleChange = (e) => {\n    let value = e.target.value;\n    if (value === \"BEGINNER\") {\n      setSpeed(Speed.BEGINNER);\n\n    }\n    else if (value === \"INTERMEDIATE\") {\n      setSpeed(Speed.INTERMEDIATE)\n    }\n    else {\n      setSpeed(Speed.PRO)\n    }\n\n  };\n  return (\n    <>\n      <div>\n        <h3 style={{ float: \"top\" }}>Choose level :</h3>\n        <div style={{ float: \"center\" }} >\n          <select className=\"level\"\n            onChange={(e) => handleChange(e)} disabled={false}>\n            <option className=\"value\" value=\"BEGINNER\">Beginner</option>\n            <option className=\"value\" value=\"INTERMEDIATE\">Intermediate</option>\n            <option className=\"value\" value=\"PRO\">Pro</option>\n          </select>\n        </div>\n      </div>\n      <div style={{ paddingTop: \"10px\" }}>\n        <button className=\"start\" >START</button>\n        <button className=\"stop\" onClick={() => handleGameOver()} >STOP</button>\n      </div>\n      <h2>Score: {score}</h2>\n      <div className=\"board\">\n        {board.map((row, rowIdx) => (\n          <div key={rowIdx} className=\"row\">\n            {row.map((cellValue, cellIdx) => {\n              const className = getCellClassName(\n                cellValue,\n                foodCell,\n                foodShouldReverseDirection,\n                snakeCells,\n              );\n              return <div key={cellIdx} className={className}></div>;\n            })}\n          </div>\n        ))}\n      </div>\n    </>\n  );\n};\n\nconst createBoard = BOARD_SIZE => {\n  let counter = 1;\n  const board = [];\n  for (let row = 0; row < BOARD_SIZE; row++) {\n    const currentRow = [];\n    for (let col = 0; col < BOARD_SIZE; col++) {\n      currentRow.push(counter++);\n    }\n    board.push(currentRow);\n  }\n  return board;\n};\n\nconst getCoordsInDirection = (coords, direction) => {\n  if (direction === Direction.UP) {\n    return {\n      row: coords.row - 1,\n      col: coords.col,\n    };\n  }\n  if (direction === Direction.RIGHT) {\n    return {\n      row: coords.row,\n      col: coords.col + 1,\n    };\n  }\n  if (direction === Direction.DOWN) {\n    return {\n      row: coords.row + 1,\n      col: coords.col,\n    };\n  }\n  if (direction === Direction.LEFT) {\n    return {\n      row: coords.row,\n      col: coords.col - 1,\n    };\n  }\n};\n\nconst isOutOfBounds = (coords, board) => {\n  const { row, col } = coords;\n  if (row < 0 || col < 0) return true;\n  if (row >= board.length || col >= board[0].length) return true;\n  return false;\n};\n\nconst getDirectionFromKey = key => {\n  if (key === 'ArrowUp') return Direction.UP;\n  if (key === 'ArrowRight') return Direction.RIGHT;\n  if (key === 'ArrowDown') return Direction.DOWN;\n  if (key === 'ArrowLeft') return Direction.LEFT;\n  return '';\n};\n\nconst getNextNodeDirection = (node, currentDirection) => {\n  if (node.next === null) return currentDirection;\n  const { row: currentRow, col: currentCol } = node.value;\n  const { row: nextRow, col: nextCol } = node.next.value;\n  if (nextRow === currentRow && nextCol === currentCol + 1) {\n    return Direction.RIGHT;\n  }\n  if (nextRow === currentRow && nextCol === currentCol - 1) {\n    return Direction.LEFT;\n  }\n  if (nextCol === currentCol && nextRow === currentRow + 1) {\n    return Direction.DOWN;\n  }\n  if (nextCol === currentCol && nextRow === currentRow - 1) {\n    return Direction.UP;\n  }\n  return '';\n};\n\nconst getGrowthNodeCoords = (snakeTail, currentDirection) => {\n  const tailNextNodeDirection = getNextNodeDirection(\n    snakeTail,\n    currentDirection,\n  );\n  const growthDirection = getOppositeDirection(tailNextNodeDirection);\n  const currentTailCoords = {\n    row: snakeTail.value.row,\n    col: snakeTail.value.col,\n  };\n  const growthNodeCoords = getCoordsInDirection(\n    currentTailCoords,\n    growthDirection,\n  );\n  return growthNodeCoords;\n};\n\nconst getOppositeDirection = direction => {\n  if (direction === Direction.UP) return Direction.DOWN;\n  if (direction === Direction.RIGHT) return Direction.LEFT;\n  if (direction === Direction.DOWN) return Direction.UP;\n  if (direction === Direction.LEFT) return Direction.RIGHT;\n};\n\nconst getCellClassName = (\n  cellValue,\n  foodCell,\n  foodShouldReverseDirection,\n  snakeCells,\n) => {\n  let className = 'cell';\n  if (cellValue === foodCell) {\n    if (foodShouldReverseDirection) {\n      className = 'cell cell-purple';\n    } else {\n      className = 'cell cell-red';\n    }\n  }\n  if (snakeCells.has(cellValue)) className = 'cell cell-green';\n\n  return className;\n};\n\nexport default Board;\n"]},"metadata":{},"sourceType":"module"}