{"ast":null,"code":"var _jsxFileName = \"/home/anjali/Desktop/Snake Game/src/Board/Board.jsx\",\n    _s = $RefreshSig$();\n\nimport React, { useEffect, useState } from 'react';\nimport { randomIntFromInterval, reverseLinkedList, useInterval } from '../lib/utils.js';\nimport './Board.css';\n/**\n * TODO: add a more elegant UX for before a game starts and after a game ends.\n * A game probably shouldn't start until the user presses an arrow key, and\n * once a game is over, the board state should likely freeze until the user\n * intentionally restarts the game.\n */\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\n\nclass LinkedListNode {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n\n}\n\nclass LinkedList {\n  constructor(value) {\n    const node = new LinkedListNode(value);\n    this.head = node;\n    this.tail = node;\n  }\n\n}\n\nconst Direction = {\n  UP: 'UP',\n  RIGHT: 'RIGHT',\n  DOWN: 'DOWN',\n  LEFT: 'LEFT'\n};\nconst Speed = {\n  BEGINNER: 200,\n  INTERMEDIATE: 150,\n  PRO: 90\n};\nconst BOARD_SIZE = 15;\nconst PROBABILITY_OF_DIRECTION_REVERSAL_FOOD = 0.2;\n\nconst getStartingSnakeLLValue = board => {\n  const rowSize = board.length;\n  const colSize = board[0].length;\n  const startingRow = Math.round(rowSize / 3);\n  const startingCol = Math.round(colSize / 3);\n  const startingCell = board[startingRow][startingCol];\n  return {\n    row: startingRow,\n    col: startingCol,\n    cell: startingCell\n  };\n};\n\nuseInterval(() => {\n  moveSnake();\n}, speed);\n\nconst Board = () => {\n  _s();\n\n  const [score, setScore] = useState(0);\n  const [board, setBoard] = useState(createBoard(BOARD_SIZE));\n  const [snake, setSnake] = useState(new LinkedList(getStartingSnakeLLValue(board)));\n  const [snakeCells, setSnakeCells] = useState(new Set([snake.head.value.cell]));\n  const [speed, setSpeed] = useState(Speed.BEGINNER); // Naively set the starting food cell 5 cells away from the starting snake cell.\n\n  const [foodCell, setFoodCell] = useState(snake.head.value.cell + 5);\n  const [direction, setDirection] = useState(Direction.RIGHT);\n  const [foodShouldReverseDirection, setFoodShouldReverseDirection] = useState(false);\n  useEffect(() => {\n    window.addEventListener('keydown', e => {\n      handleKeydown(e);\n    });\n  }, []); // `useInterval` is needed; you can't naively do `setInterval` in the\n  // `useEffect` above. See the article linked above the `useInterval`\n  // definition for details.\n\n  const handleKeydown = e => {\n    const newDirection = getDirectionFromKey(e.key);\n    const isValidDirection = newDirection !== '';\n    if (!isValidDirection) return;\n    const snakeWillRunIntoItself = getOppositeDirection(newDirection) === direction && snakeCells.size > 1; // Note: this functionality is currently broken, for the same reason that\n    // `useInterval` is needed. Specifically, the `direction` and `snakeCells`\n    // will currently never reflect their \"latest version\" when `handleKeydown`\n    // is called. I leave it as an exercise to the viewer to fix this :P\n\n    if (snakeWillRunIntoItself) return;\n    setDirection(newDirection);\n  };\n\n  const moveSnake = () => {\n    const currentHeadCoords = {\n      row: snake.head.value.row,\n      col: snake.head.value.col\n    };\n    const nextHeadCoords = getCoordsInDirection(currentHeadCoords, direction);\n\n    if (isOutOfBounds(nextHeadCoords, board)) {\n      handleGameOver();\n      return;\n    }\n\n    const nextHeadCell = board[nextHeadCoords.row][nextHeadCoords.col];\n\n    if (snakeCells.has(nextHeadCell)) {\n      handleGameOver();\n      return;\n    }\n\n    const newHead = new LinkedListNode({\n      row: nextHeadCoords.row,\n      col: nextHeadCoords.col,\n      cell: nextHeadCell\n    });\n    const currentHead = snake.head;\n    snake.head = newHead;\n    currentHead.next = newHead;\n    const newSnakeCells = new Set(snakeCells);\n    newSnakeCells.delete(snake.tail.value.cell);\n    newSnakeCells.add(nextHeadCell);\n    snake.tail = snake.tail.next;\n    if (snake.tail === null) snake.tail = snake.head;\n    const foodConsumed = nextHeadCell === foodCell;\n\n    if (foodConsumed) {\n      // This function mutates newSnakeCells.\n      growSnake(newSnakeCells);\n      if (foodShouldReverseDirection) reverseSnake();\n      handleFoodConsumption(newSnakeCells);\n    }\n\n    setSnakeCells(newSnakeCells);\n  }; // This function mutates newSnakeCells.\n\n\n  const growSnake = newSnakeCells => {\n    const growthNodeCoords = getGrowthNodeCoords(snake.tail, direction);\n\n    if (isOutOfBounds(growthNodeCoords, board)) {\n      // Snake is positioned such that it can't grow; don't do anything.\n      return;\n    }\n\n    const newTailCell = board[growthNodeCoords.row][growthNodeCoords.col];\n    const newTail = new LinkedListNode({\n      row: growthNodeCoords.row,\n      col: growthNodeCoords.col,\n      cell: newTailCell\n    });\n    const currentTail = snake.tail;\n    snake.tail = newTail;\n    snake.tail.next = currentTail;\n    newSnakeCells.add(newTailCell);\n  };\n\n  const reverseSnake = () => {\n    const tailNextNodeDirection = getNextNodeDirection(snake.tail, direction);\n    const newDirection = getOppositeDirection(tailNextNodeDirection);\n    setDirection(newDirection); // The tail of the snake is really the head of the linked list, which\n    // is why we have to pass the snake's tail to `reverseLinkedList`.\n\n    reverseLinkedList(snake.tail);\n    const snakeHead = snake.head;\n    snake.head = snake.tail;\n    snake.tail = snakeHead;\n  };\n\n  const handleFoodConsumption = newSnakeCells => {\n    const maxPossibleCellValue = BOARD_SIZE * BOARD_SIZE;\n    let nextFoodCell; // In practice, this will never be a time-consuming operation. Even\n    // in the extreme scenario where a snake is so big that it takes up 90%\n    // of the board (nearly impossible), there would be a 10% chance of generating\n    // a valid new food cell--so an average of 10 operations: trivial.\n\n    while (true) {\n      nextFoodCell = randomIntFromInterval(1, maxPossibleCellValue);\n      if (newSnakeCells.has(nextFoodCell) || foodCell === nextFoodCell) continue;\n      break;\n    }\n\n    const nextFoodShouldReverseDirection = Math.random() < PROBABILITY_OF_DIRECTION_REVERSAL_FOOD;\n    setFoodCell(nextFoodCell);\n    setFoodShouldReverseDirection(nextFoodShouldReverseDirection);\n    setScore(score + 1);\n  };\n\n  const handleGameOver = () => {\n    setScore(0);\n    const snakeLLStartingValue = getStartingSnakeLLValue(board);\n    setSnake(new LinkedList(snakeLLStartingValue));\n    setFoodCell(snakeLLStartingValue.cell + 5);\n    setSnakeCells(new Set([snakeLLStartingValue.cell]));\n    setDirection(Direction.RIGHT);\n  };\n\n  const handleChange = e => {\n    let value = e.target.value;\n\n    if (value == \"BEGINNER\") {\n      setSpeed(Speed.BEGINNER);\n    } else if (value == \"INTERMEDIATE\") {\n      setSpeed(Speed.INTERMEDIATE);\n    } else {\n      setSpeed(Speed.PRO);\n    }\n  };\n\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        style: {\n          float: \"top\"\n        },\n        children: \"Choose level :\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 232,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          float: \"center\"\n        },\n        children: /*#__PURE__*/_jsxDEV(\"select\", {\n          className: \"level\",\n          onChange: e => handleChange(e),\n          disabled: false,\n          children: [/*#__PURE__*/_jsxDEV(\"option\", {\n            className: \"value\",\n            value: \"BEGINNER\",\n            children: \"Beginner\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 236,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n            className: \"value\",\n            value: \"INTERMEDIATE\",\n            children: \"Intermediate\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 237,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"option\", {\n            className: \"value\",\n            value: \"PRO\",\n            children: \"Pro\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 238,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 234,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 233,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 231,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        paddingTop: \"10px\"\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"start\",\n        children: \"START\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 243,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"stop\",\n        onClick: () => handleGameOver(),\n        children: \"STOP\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 244,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 242,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"h2\", {\n      children: [\"Score: \", score]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 246,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"board\",\n      children: board.map((row, rowIdx) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"row\",\n        children: row.map((cellValue, cellIdx) => {\n          const className = getCellClassName(cellValue, foodCell, foodShouldReverseDirection, snakeCells);\n          return /*#__PURE__*/_jsxDEV(\"div\", {\n            className: className\n          }, cellIdx, false, {\n            fileName: _jsxFileName,\n            lineNumber: 257,\n            columnNumber: 22\n          }, this);\n        })\n      }, rowIdx, false, {\n        fileName: _jsxFileName,\n        lineNumber: 249,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 247,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true);\n};\n\n_s(Board, \"w1t0JeR2NcubhRZyhMjKKZlDtCY=\");\n\n_c = Board;\n\nconst createBoard = BOARD_SIZE => {\n  let counter = 1;\n  const board = [];\n\n  for (let row = 0; row < BOARD_SIZE; row++) {\n    const currentRow = [];\n\n    for (let col = 0; col < BOARD_SIZE; col++) {\n      currentRow.push(counter++);\n    }\n\n    board.push(currentRow);\n  }\n\n  return board;\n};\n\nconst getCoordsInDirection = (coords, direction) => {\n  if (direction === Direction.UP) {\n    return {\n      row: coords.row - 1,\n      col: coords.col\n    };\n  }\n\n  if (direction === Direction.RIGHT) {\n    return {\n      row: coords.row,\n      col: coords.col + 1\n    };\n  }\n\n  if (direction === Direction.DOWN) {\n    return {\n      row: coords.row + 1,\n      col: coords.col\n    };\n  }\n\n  if (direction === Direction.LEFT) {\n    return {\n      row: coords.row,\n      col: coords.col - 1\n    };\n  }\n};\n\nconst isOutOfBounds = (coords, board) => {\n  const {\n    row,\n    col\n  } = coords;\n  if (row < 0 || col < 0) return true;\n  if (row >= board.length || col >= board[0].length) return true;\n  return false;\n};\n\nconst getDirectionFromKey = key => {\n  if (key === 'ArrowUp') return Direction.UP;\n  if (key === 'ArrowRight') return Direction.RIGHT;\n  if (key === 'ArrowDown') return Direction.DOWN;\n  if (key === 'ArrowLeft') return Direction.LEFT;\n  return '';\n};\n\nconst getNextNodeDirection = (node, currentDirection) => {\n  if (node.next === null) return currentDirection;\n  const {\n    row: currentRow,\n    col: currentCol\n  } = node.value;\n  const {\n    row: nextRow,\n    col: nextCol\n  } = node.next.value;\n\n  if (nextRow === currentRow && nextCol === currentCol + 1) {\n    return Direction.RIGHT;\n  }\n\n  if (nextRow === currentRow && nextCol === currentCol - 1) {\n    return Direction.LEFT;\n  }\n\n  if (nextCol === currentCol && nextRow === currentRow + 1) {\n    return Direction.DOWN;\n  }\n\n  if (nextCol === currentCol && nextRow === currentRow - 1) {\n    return Direction.UP;\n  }\n\n  return '';\n};\n\nconst getGrowthNodeCoords = (snakeTail, currentDirection) => {\n  const tailNextNodeDirection = getNextNodeDirection(snakeTail, currentDirection);\n  const growthDirection = getOppositeDirection(tailNextNodeDirection);\n  const currentTailCoords = {\n    row: snakeTail.value.row,\n    col: snakeTail.value.col\n  };\n  const growthNodeCoords = getCoordsInDirection(currentTailCoords, growthDirection);\n  return growthNodeCoords;\n};\n\nconst getOppositeDirection = direction => {\n  if (direction === Direction.UP) return Direction.DOWN;\n  if (direction === Direction.RIGHT) return Direction.LEFT;\n  if (direction === Direction.DOWN) return Direction.UP;\n  if (direction === Direction.LEFT) return Direction.RIGHT;\n};\n\nconst getCellClassName = (cellValue, foodCell, foodShouldReverseDirection, snakeCells) => {\n  let className = 'cell';\n\n  if (cellValue === foodCell) {\n    if (foodShouldReverseDirection) {\n      className = 'cell cell-purple';\n    } else {\n      className = 'cell cell-red';\n    }\n  }\n\n  if (snakeCells.has(cellValue)) className = 'cell cell-green';\n  return className;\n};\n\nexport default Board;\n\nvar _c;\n\n$RefreshReg$(_c, \"Board\");","map":{"version":3,"sources":["/home/anjali/Desktop/Snake Game/src/Board/Board.jsx"],"names":["React","useEffect","useState","randomIntFromInterval","reverseLinkedList","useInterval","LinkedListNode","constructor","value","next","LinkedList","node","head","tail","Direction","UP","RIGHT","DOWN","LEFT","Speed","BEGINNER","INTERMEDIATE","PRO","BOARD_SIZE","PROBABILITY_OF_DIRECTION_REVERSAL_FOOD","getStartingSnakeLLValue","board","rowSize","length","colSize","startingRow","Math","round","startingCol","startingCell","row","col","cell","moveSnake","speed","Board","score","setScore","setBoard","createBoard","snake","setSnake","snakeCells","setSnakeCells","Set","setSpeed","foodCell","setFoodCell","direction","setDirection","foodShouldReverseDirection","setFoodShouldReverseDirection","window","addEventListener","e","handleKeydown","newDirection","getDirectionFromKey","key","isValidDirection","snakeWillRunIntoItself","getOppositeDirection","size","currentHeadCoords","nextHeadCoords","getCoordsInDirection","isOutOfBounds","handleGameOver","nextHeadCell","has","newHead","currentHead","newSnakeCells","delete","add","foodConsumed","growSnake","reverseSnake","handleFoodConsumption","growthNodeCoords","getGrowthNodeCoords","newTailCell","newTail","currentTail","tailNextNodeDirection","getNextNodeDirection","snakeHead","maxPossibleCellValue","nextFoodCell","nextFoodShouldReverseDirection","random","snakeLLStartingValue","handleChange","target","float","paddingTop","map","rowIdx","cellValue","cellIdx","className","getCellClassName","counter","currentRow","push","coords","currentDirection","currentCol","nextRow","nextCol","snakeTail","growthDirection","currentTailCoords"],"mappings":"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","sourcesContent":["import React, { useEffect, useState } from 'react';\nimport {\n  randomIntFromInterval,\n  reverseLinkedList,\n  useInterval,\n} from '../lib/utils.js';\n\nimport './Board.css';\n\n/**\n * TODO: add a more elegant UX for before a game starts and after a game ends.\n * A game probably shouldn't start until the user presses an arrow key, and\n * once a game is over, the board state should likely freeze until the user\n * intentionally restarts the game.\n */\n\nclass LinkedListNode {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nclass LinkedList {\n  constructor(value) {\n    const node = new LinkedListNode(value);\n    this.head = node;\n    this.tail = node;\n  }\n}\n\nconst Direction = {\n  UP: 'UP',\n  RIGHT: 'RIGHT',\n  DOWN: 'DOWN',\n  LEFT: 'LEFT',\n};\n\nconst Speed = {\n  BEGINNER: 200,\n  INTERMEDIATE: 150,\n  PRO: 90\n};\n\nconst BOARD_SIZE = 15;\nconst PROBABILITY_OF_DIRECTION_REVERSAL_FOOD = 0.2;\n\nconst getStartingSnakeLLValue = board => {\n  const rowSize = board.length;\n  const colSize = board[0].length;\n  const startingRow = Math.round(rowSize / 3);\n  const startingCol = Math.round(colSize / 3);\n  const startingCell = board[startingRow][startingCol];\n\n  return {\n    row: startingRow,\n    col: startingCol,\n    cell: startingCell,\n  };\n};\nuseInterval(() => {\n\n  moveSnake();\n}, speed);\n\nconst Board = () => {\n  const [score, setScore] = useState(0);\n  const [board, setBoard] = useState(createBoard(BOARD_SIZE));\n  const [snake, setSnake] = useState(\n    new LinkedList(getStartingSnakeLLValue(board)),\n  );\n  const [snakeCells, setSnakeCells] = useState(\n    new Set([snake.head.value.cell]),\n  );\n  const [speed, setSpeed] = useState(Speed.BEGINNER);\n\n  // Naively set the starting food cell 5 cells away from the starting snake cell.\n  const [foodCell, setFoodCell] = useState(snake.head.value.cell + 5);\n  const [direction, setDirection] = useState(Direction.RIGHT);\n  const [foodShouldReverseDirection, setFoodShouldReverseDirection] = useState(\n    false,\n  );\n\n  useEffect(() => {\n    window.addEventListener('keydown', e => {\n      handleKeydown(e);\n    });\n  }, []);\n\n  // `useInterval` is needed; you can't naively do `setInterval` in the\n  // `useEffect` above. See the article linked above the `useInterval`\n  // definition for details.\n\n  const handleKeydown = e => {\n    const newDirection = getDirectionFromKey(e.key);\n    const isValidDirection = newDirection !== '';\n    if (!isValidDirection) return;\n    const snakeWillRunIntoItself =\n      getOppositeDirection(newDirection) === direction && snakeCells.size > 1;\n    // Note: this functionality is currently broken, for the same reason that\n    // `useInterval` is needed. Specifically, the `direction` and `snakeCells`\n    // will currently never reflect their \"latest version\" when `handleKeydown`\n    // is called. I leave it as an exercise to the viewer to fix this :P\n    if (snakeWillRunIntoItself) return;\n    setDirection(newDirection);\n  };\n\n  const moveSnake = () => {\n    const currentHeadCoords = {\n      row: snake.head.value.row,\n      col: snake.head.value.col,\n    };\n\n    const nextHeadCoords = getCoordsInDirection(currentHeadCoords, direction);\n    if (isOutOfBounds(nextHeadCoords, board)) {\n      handleGameOver();\n      return;\n    }\n    const nextHeadCell = board[nextHeadCoords.row][nextHeadCoords.col];\n    if (snakeCells.has(nextHeadCell)) {\n      handleGameOver();\n      return;\n    }\n\n    const newHead = new LinkedListNode({\n      row: nextHeadCoords.row,\n      col: nextHeadCoords.col,\n      cell: nextHeadCell,\n    });\n    const currentHead = snake.head;\n    snake.head = newHead;\n    currentHead.next = newHead;\n\n    const newSnakeCells = new Set(snakeCells);\n    newSnakeCells.delete(snake.tail.value.cell);\n    newSnakeCells.add(nextHeadCell);\n\n    snake.tail = snake.tail.next;\n    if (snake.tail === null) snake.tail = snake.head;\n\n    const foodConsumed = nextHeadCell === foodCell;\n    if (foodConsumed) {\n      // This function mutates newSnakeCells.\n      growSnake(newSnakeCells);\n      if (foodShouldReverseDirection) reverseSnake();\n      handleFoodConsumption(newSnakeCells);\n    }\n\n    setSnakeCells(newSnakeCells);\n  };\n\n  // This function mutates newSnakeCells.\n  const growSnake = newSnakeCells => {\n    const growthNodeCoords = getGrowthNodeCoords(snake.tail, direction);\n    if (isOutOfBounds(growthNodeCoords, board)) {\n      // Snake is positioned such that it can't grow; don't do anything.\n      return;\n    }\n    const newTailCell = board[growthNodeCoords.row][growthNodeCoords.col];\n    const newTail = new LinkedListNode({\n      row: growthNodeCoords.row,\n      col: growthNodeCoords.col,\n      cell: newTailCell,\n    });\n    const currentTail = snake.tail;\n    snake.tail = newTail;\n    snake.tail.next = currentTail;\n\n    newSnakeCells.add(newTailCell);\n  };\n\n  const reverseSnake = () => {\n    const tailNextNodeDirection = getNextNodeDirection(snake.tail, direction);\n    const newDirection = getOppositeDirection(tailNextNodeDirection);\n    setDirection(newDirection);\n\n    // The tail of the snake is really the head of the linked list, which\n    // is why we have to pass the snake's tail to `reverseLinkedList`.\n    reverseLinkedList(snake.tail);\n    const snakeHead = snake.head;\n    snake.head = snake.tail;\n    snake.tail = snakeHead;\n  };\n\n  const handleFoodConsumption = newSnakeCells => {\n    const maxPossibleCellValue = BOARD_SIZE * BOARD_SIZE;\n    let nextFoodCell;\n    // In practice, this will never be a time-consuming operation. Even\n    // in the extreme scenario where a snake is so big that it takes up 90%\n    // of the board (nearly impossible), there would be a 10% chance of generating\n    // a valid new food cell--so an average of 10 operations: trivial.\n    while (true) {\n      nextFoodCell = randomIntFromInterval(1, maxPossibleCellValue);\n      if (newSnakeCells.has(nextFoodCell) || foodCell === nextFoodCell)\n        continue;\n      break;\n    }\n\n    const nextFoodShouldReverseDirection =\n      Math.random() < PROBABILITY_OF_DIRECTION_REVERSAL_FOOD;\n\n    setFoodCell(nextFoodCell);\n    setFoodShouldReverseDirection(nextFoodShouldReverseDirection);\n    setScore(score + 1);\n  };\n\n  const handleGameOver = () => {\n    setScore(0);\n    const snakeLLStartingValue = getStartingSnakeLLValue(board);\n    setSnake(new LinkedList(snakeLLStartingValue));\n    setFoodCell(snakeLLStartingValue.cell + 5);\n    setSnakeCells(new Set([snakeLLStartingValue.cell]));\n    setDirection(Direction.RIGHT);\n  };\n  const handleChange = (e) => {\n    let value = e.target.value;\n    if (value == \"BEGINNER\") {\n      setSpeed(Speed.BEGINNER);\n\n    }\n    else if (value == \"INTERMEDIATE\") {\n      setSpeed(Speed.INTERMEDIATE)\n    }\n    else {\n      setSpeed(Speed.PRO)\n    }\n\n  };\n  return (\n    <>\n      <div>\n        <h3 style={{ float: \"top\" }}>Choose level :</h3>\n        <div style={{ float: \"center\" }} >\n          <select className=\"level\"\n            onChange={(e) => handleChange(e)} disabled={false}>\n            <option className=\"value\" value=\"BEGINNER\">Beginner</option>\n            <option className=\"value\" value=\"INTERMEDIATE\">Intermediate</option>\n            <option className=\"value\" value=\"PRO\">Pro</option>\n          </select>\n        </div>\n      </div>\n      <div style={{ paddingTop: \"10px\" }}>\n        <button className=\"start\" >START</button>\n        <button className=\"stop\" onClick={() => handleGameOver()} >STOP</button>\n      </div>\n      <h2>Score: {score}</h2>\n      <div className=\"board\">\n        {board.map((row, rowIdx) => (\n          <div key={rowIdx} className=\"row\">\n            {row.map((cellValue, cellIdx) => {\n              const className = getCellClassName(\n                cellValue,\n                foodCell,\n                foodShouldReverseDirection,\n                snakeCells,\n              );\n              return <div key={cellIdx} className={className}></div>;\n            })}\n          </div>\n        ))}\n      </div>\n    </>\n  );\n};\n\nconst createBoard = BOARD_SIZE => {\n  let counter = 1;\n  const board = [];\n  for (let row = 0; row < BOARD_SIZE; row++) {\n    const currentRow = [];\n    for (let col = 0; col < BOARD_SIZE; col++) {\n      currentRow.push(counter++);\n    }\n    board.push(currentRow);\n  }\n  return board;\n};\n\nconst getCoordsInDirection = (coords, direction) => {\n  if (direction === Direction.UP) {\n    return {\n      row: coords.row - 1,\n      col: coords.col,\n    };\n  }\n  if (direction === Direction.RIGHT) {\n    return {\n      row: coords.row,\n      col: coords.col + 1,\n    };\n  }\n  if (direction === Direction.DOWN) {\n    return {\n      row: coords.row + 1,\n      col: coords.col,\n    };\n  }\n  if (direction === Direction.LEFT) {\n    return {\n      row: coords.row,\n      col: coords.col - 1,\n    };\n  }\n};\n\nconst isOutOfBounds = (coords, board) => {\n  const { row, col } = coords;\n  if (row < 0 || col < 0) return true;\n  if (row >= board.length || col >= board[0].length) return true;\n  return false;\n};\n\nconst getDirectionFromKey = key => {\n  if (key === 'ArrowUp') return Direction.UP;\n  if (key === 'ArrowRight') return Direction.RIGHT;\n  if (key === 'ArrowDown') return Direction.DOWN;\n  if (key === 'ArrowLeft') return Direction.LEFT;\n  return '';\n};\n\nconst getNextNodeDirection = (node, currentDirection) => {\n  if (node.next === null) return currentDirection;\n  const { row: currentRow, col: currentCol } = node.value;\n  const { row: nextRow, col: nextCol } = node.next.value;\n  if (nextRow === currentRow && nextCol === currentCol + 1) {\n    return Direction.RIGHT;\n  }\n  if (nextRow === currentRow && nextCol === currentCol - 1) {\n    return Direction.LEFT;\n  }\n  if (nextCol === currentCol && nextRow === currentRow + 1) {\n    return Direction.DOWN;\n  }\n  if (nextCol === currentCol && nextRow === currentRow - 1) {\n    return Direction.UP;\n  }\n  return '';\n};\n\nconst getGrowthNodeCoords = (snakeTail, currentDirection) => {\n  const tailNextNodeDirection = getNextNodeDirection(\n    snakeTail,\n    currentDirection,\n  );\n  const growthDirection = getOppositeDirection(tailNextNodeDirection);\n  const currentTailCoords = {\n    row: snakeTail.value.row,\n    col: snakeTail.value.col,\n  };\n  const growthNodeCoords = getCoordsInDirection(\n    currentTailCoords,\n    growthDirection,\n  );\n  return growthNodeCoords;\n};\n\nconst getOppositeDirection = direction => {\n  if (direction === Direction.UP) return Direction.DOWN;\n  if (direction === Direction.RIGHT) return Direction.LEFT;\n  if (direction === Direction.DOWN) return Direction.UP;\n  if (direction === Direction.LEFT) return Direction.RIGHT;\n};\n\nconst getCellClassName = (\n  cellValue,\n  foodCell,\n  foodShouldReverseDirection,\n  snakeCells,\n) => {\n  let className = 'cell';\n  if (cellValue === foodCell) {\n    if (foodShouldReverseDirection) {\n      className = 'cell cell-purple';\n    } else {\n      className = 'cell cell-red';\n    }\n  }\n  if (snakeCells.has(cellValue)) className = 'cell cell-green';\n\n  return className;\n};\n\nexport default Board;\n"]},"metadata":{},"sourceType":"module"}